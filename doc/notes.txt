
sessions	(key: clid)
------------------------------------------------------

clid:		client id
addr:		IP address
last_contact:	time of last contact
next_handle:	number of next file handle


handles		(key: clid, hid)
------------------------------------------------------

clid:		client id
hid:		handle id
ino:		inode
mode:		open mode
events:		event mask

inodes		(key: name)
------------------------------------------------------

name
size
create time
last mod time
number of handles
list of handles

data		(key: inode name)
------------------------------------------------------

.. raw data ..


=========================================================================



Here is a rough overview of my idea for the official CLD client lib API:

1. filesystem operations

    // set up app-wide callback for events like 'master failed'
    set_event_cb(cb)
    
    // start asynchronous filesystem operation
    txnid = sess_open()
    txnid = sess_close(sess)
    txnid = open(pathname, flags, event_callback)
    txnid = close(fh)
    txnid = get(fh)
    txnid = put(fh, data)
    txnid = del(pathname)
    txnid = lock(fh)
    txnid = trylock(fh)
    txnid = unlock(fh)

    // wait for completion and results

    op_wait(txnid, &result)    // sleep (block) until op completes

    op_cb(txnid, cb)    // call callback with result,
                // when op completes

2. message glue layer

    receive_packet()    // called when EV_READ fires

    ->replica_list()    // called by lib, to get list of
                // replicas (i.e. SRV DNS lookup)
    ->send_packet()        // called by lib, to output pkt
    ->set_event_mask()    // called by lib, to set/clear r/w waits

3. POSIX/UDP helper layer

    Implementation of the message glue layer (#2) using DNS lookups,
    UDP sockets, recvmsg(2), sendmsg(2), etc. 

